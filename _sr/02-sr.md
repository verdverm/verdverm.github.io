---
layout: sr
title: Symbolic Regression
brief: Overview, context, details, implementations
prev: 01-intro
next: 03-relatedwork
nextname: The PGE algorithm
sections:
  - name: The Problem
    tag: problem
    brief: Definition, classes, applications
  - name: The Components
    tag: components
    brief: Representation, evaluation, optimization, memoization
  - name: The Algorithm
    tag: algorithm
    brief: Search space, relationships, learning loop
  - name: Implementations
    tag: implementations
    brief: PGE, FFX, basic and contemporary GP
  - name: Applications
    tag: applications
    brief: Where SR can been applied
  - name: Further Considerations
    tag: considerations
    brief: Terminonolgy, implementation evaluation, reproducibility
---


Symbolic Regression (SR) is
the task of deriving mathematical formula
from observational data without any fore-knowledge
of the domain or problem.
In essence, this is the scientific process
performed by a computer.
Hypotheses are formulated,
tested against the observations,
and compared for explanatory value.
This process mirrors our human notions for 
mathematical discovery in science and engineering.

<br>

<div id="problem"></div>
<a class="right" href="#top">top</a>

### The Problem


The overall goal of SR is to produce
models which find a balance in the
trade-off between accuracy and complexity.
The best models will therefore be
both simple and explanatory,
elucidating the dynamics of the system under study.
In this way, an expert is freed
to think about the larger and more complex
aspects of that system,
gaining insights from the results of SR.

The domain of SR is to model a dataset
with a mathematical formula or equation.
SR makes no a priori assumptions about the form of a model.
In SR, the search encompases the space of all equations.
Compare this with more traditional
methods for regression.
Linear and non-linear regression
assume a model and fit 
the model's parameters
to the data on hand.
More sophisticated methods like 
the Fourier transform and neural networks
can model almost any signal or function.
However, they don't elucidate an understanding of the
interactions and behavior of that signal or function.
SR is often considered a generalization of
traditional methods for regression.
A SR implementation will generate, tests, and validated
a massive number of equations.
Thus it is flexible, capable of modelling almost any signal,
and also explanitory, producing models which
are easily interpreted by humans.

Because SR models data with equations,
it also finds a vast array of application domains.
Simple relationships are modeled with
explicit functions.
Time variant relationships are modeled with
differential equations.
Several differential equations can be combined into
a set, forming a dynamical system.
Relationships with vary in both time and space
are modeled with partial differential equations.
Invariants, or conserved quantities can also be modeled
with an equation and its partial derivatives.
These are all incantations of ideas from calculus
and are prominent throughout the sciences and engineering.
From 
cell biology to ecology, 
physics to astronomy,
chemistry to pharmaceuticals,
engineering and finance;
all fields rely on
mathematical notions and theory
to produce solid foundations
upon which decisions can be made.


Looking forward, a SR technology will.
be a tool of great assistance to domain experts.
The ability to automatically discover analytical models
from our increasing volumes and complexity of data is paramount
to continued scientific progress.
The equation and formula models are human interpretable,
precisely because they are a human conception and language
for talking about functional relationships
found in the world.
It is the relation between
humans, math, and science;
that SR holds a special place.
As a tool for helping humans
make sense in a data driven world.
SR holds the potential to
accelerate the pace of 
scientific breakthroughs.






#### The Search Space

The equation search space is defined
by a grammar through its terminals,
non-terminals, and production rules.
It is an exponential space that
can be represented as a tree or a graph.
As a tree, the space is the ordered expansion of applied productions,
with the start symbol at the root.
The graph is similar, but connects
nodes in the tree that are equivalent.
In the graph, there are multiple paths
to an equation, coinciding with the multiple
derivations for an equations parse tree.

Defining the building blocks 
from which equations can be built,
also defines the space
of representable expressions
that be searched.
The size of this space is infinite
even when disregarding the 
massive increase brought on by real valued coefficients.
This is because a grammar is infinite
through its production rules.
Even further, the same expression
can have a multitude of parse trees.
Consider the equation $a+b+c$ (Figure \ref{fig:eqn-combis} left and middle columns). 
This equation has 12 different binary tree representations,
six leaf permutations and 2 shape permutations.
If we add multiplication to the mix,
this number increases to 48.
As the number of operations,
operands, and tree size are increased,
the size of the search space
experiences a combinatorial explosion.
Some example equation spaces to consider are: 
\begin{itemize}
\item The space of all polynomials in one variable
\item The space of all polynomials in more than one variable
\item The last item with trig, log, \ldots 
\item Increasing the depth of expressions (i.e. allowing recursive `()') 
\item Allowing division (put any of the previous spaces on top, bottom, or both) 
\newline
\end{itemize}















<br>
 
<div id="components"></div>
<a class="right" href="#top">top</a>

### The Components


Like all machine learning tasks,
SR can be logically broken into three components: 
Representation, Evaluation, and Optimization 
[[Pedro:20??:ml](), [Mustafa - Learning from Data]()].
Representations are the conceptual and implementation
models we choose, and which define the hypothesis space.
Evaluation determines a model's fitness,
and is defined by the objective function.
Optimization is then the technique
which explores the representational space
and maximizes model fitness.
Often these three components have a
high degree of coupling or co-dependence.
That is, optimization techniques usually
have a representation and objective in mind.

In our work, we additionally include a memoization component
for tracking the sub-problems previously solved.
Memoization is necessary in SR as the representational space 
contains an extremely high degree of overlapping subproblems.
If we did not detect overlap, we would experience 
a high degree of repetition and process the same 
equations many times. To our knowledge,
this is a first for the SR research community.



#### Representation in Symbolic Regression

In SR,
equations need to be represented *in cilico*.
The choice of representation 
determines the methods
we can later use to work with the equations.
As we will see, there are tradeoffs
when choosing between them.
There is also opportunity
to use multiple representations simultaneously
and will prove to be beneficial.

Of the many equation representations
which have been explored in SR research,
binary trees are the most common.
They fit naturally with the theoretical concepts
and simplify the underlying algorithms.
Tree representationss in SR can be 
subdivided into binary and n-ary.
Binary trees are natural to computers,
n-ary tries are natural to algebra.
Graph and linear representations 
have been used as well.
All of the representations
are interchangeable and we
are able to transform between
them. This is important as
each representation has its benefits
and can be useful to different 
subtasks in the SR problem.


**Linguistic Foundations**

Before we explore each representation,
some context for the discussion is in order.
In this work, we take a strong point of view
from a language perspective.
This perspective mainly comes from a
computational background, in terms of
regular languages, but also from 
and algebraic perspective.
It was this perspective which 
lead to the PGE algorithm
and underpins much of our foundation.

From a programmers point of view,
a grammar defines a language in a recursive manner 
[ [Aho:1972:TPT](http://dl.acm.org/citation.cfm?id=578789), [Dragon Book](http://dragonbook.stanford.edu/) ]. 
A grammar is comprised of a start symbol,
nonterminals, terminals, and production rules.
The language generated by a grammar G, denoted L(G),
is the set of sentences generated by G.
A sentence *S* is in L(G) if there is 
a sequence productions which results *S*.
This sequence of productions constructs
the derivation for *S*.
If a sentence *S* has a derivation
then it is in the language G.
Thus, grammar allows us to determine if 
a sentence is in a language.

Below is a simplified example 
for a grammar for mathematics.

    START -> E
    E -> E + T | E - T | T
    T -> T * N | T / N | N
    N -> Cos(E) | Sin(E) | Tan(E) | Log(E) | Exp(E) | L
    L -> (E) | -(E) | (E)^(E) | TERM 
    TERM -> Constant | Variable

When working with languages in computers,
expressions are represented as trees.
The trees represent the application
of the production rules for a grammar. 
They are often refered to as syntax or parse trees.
The grammar can then be used to determine if a
tree is valid by finding a matching
set of production rule applications.
In PGE, the production rules will
also provide a means to
recursively enumerate sentences in a language.



**Binary Trees**

In Symbolic Regression,
equations are constructed as binary trees
made of basic components called building blocks.
The tree of building blocks 
makes up the *DNA* of an equation.
It matches the parse or derivation tree 
for a given equation, and can also
be called its Abstract Syntax Tree (AST). 
Building blocks come in two types,
operators and operands.
Operators are the internal nodes of the AST and
include familiar mathematical functions $$ (+,-,*,/,sin,cos,...) $$.
Operands are the terminals or leafs of the AST
and represent state-variables, constants, and real-valued numbers.
There are two ways to represent constant,
indexed and floating point.
The real value floating point representation
has been the most common in GP literature.
The value is randomly assigned, mutated
by multiplying  it by a small number 
or swapping it out with another during crossover. 
Indexing associates a constant in the tree
with an element into an array. This permits
the coefficients to be optimized outside
of the equation form. This can be done
by a second evolutionary algorithm
or by standard regression techniques.
We use real-valued coefficients in GP
and indexed coefficients in PGE.


**Algebra Tries**

The algebra *trie*, or just plain *trie*,
is a tree structure
where each operand can have a variable number of children.
The algebra trie representation 
only affects two operators in SR,
addition and multiplication.
In fact, in any tree based representation,
some operators (internal nodes)
such as $$cos$$ and $$log$$ always have
only one outgoing edge to their operand.
Figure \ref{fig:eqn-trees} shows
the comparable representations
of several equations as both
binary and algebra tries.

<div class="center-align">
<span><b>Figure #</b> - Binary Trees and Algebra Tries</span>
<img class="responsive-img" src="/sr/img/eqn-trees.jpg" />
</div>

Describe image...

The algebra trie representation
has no effect on the 
constituents or modeling ability of the equation.
It does however, alter the equation tree's size and structure.
Changing size of equations 
effects the trade-off between parsimony and accuracy.
This multi-objective trade-off, 
often called Pareto sorting, 
is the multi-objective optimization search of SR.
Any change to the fitness function undoubtedly effects 
the operation of any SR implementation.

Additionally, the trie representation
eases the design of simplification algorithms.
These algorithms
work within the tree
to rewrite it to a canonical form.
The simplification algorithms are analogous to 
rewrite rules from parser literature 
[ [Aho:1972:TPT](http://dl.acm.org/citation.cfm?id=578789) ],
and are reminiscent of high school algebra.

The implications of tries
and associated algorithms
have largely been unexplored
in the SR community.
Despite the lack of detailed analyses,
our theories and experience have shown
their use to greately increase
the tractability of SR.
As such, we will use them exclusively
and omit the use of binary trees.




**Linear Forms**

Linear representations come in 
a few flavors.

Prefix notation

Linear GP


In Fast Function eXtraction \cite{McConaghy:2011:FFX}, 
described in section \ref{subsec-ffx},
equations are represented as a
linear combination of simple basis functions.




**Other Representations**

In Genetic Programming, 
binary trees have been the prevailing method
for representing equations.
There have alse been several
other representations
which have been explored.

Graph representatios...

\cite{Hod:2007:graphrep} considered 
graph representations for equations,
sometimes referred to as Cartesian GP \cite{miller:2000:cartesian}.




**Restrictions and Simplifications**

% Considering $a+b+c$ further (Figure \ref{fig:abc}),
% there are multiple paths to the
% parse tree for this expression.
% The equation search space is then
% actually a search graph, not a search tree.
% Equivalent forms would have cross connections
% through the rewrite rules.
The space of equations can be consolidated
by imposing restrictions,
weak ordering sub-expressions,
and simplifying equations with rewrite rules.
These methods drastically
reduce the size of the space to be searched.

Simple restrictions disallow invalid mathematics,
operations such as dividing by zero 
or taking the logarithm of a negative number.
This is sometimes called interval arithmatic
in the literature \cite{keijzer:03:improving}.
In general, we wish to only consider valid equations.
Partial weak ordering of the building blocks,
is achieved by placing a relative order 
on each building block type.
Weak ordered type information provides 
the necessary machinery for sorting associative operators.
Sorting is further eased by the n-ary representation.
Since addition and multiplication are the only associative operations we consider,
they are the only building blocks effected by ordering and sorting.
Figure \ref{fig:eqn-combis} right column shows 
the canonical form of $a+b+c$ with a algebra trie and weak ordering. 
If $a<b<c$, 
then there is only one representation of this expression.
Weak ordering, coupled with the algebra trie
enables a twelve-fold reduction of the search space.

Simplification groups like terms together, 
remove sub-expressions which evaluate 
to a constant value ($$\sin\pi$$, $$\frac{x}{x}$$, or $$x-x$$),
and reduce unnecessarily complex expressions such as $$\frac{1}{\frac{1}{x}}$$.
These algorithms, known as tree rewriting systems 
[ [Joshi:1975:TAG](), [dershowitz:1982:orderings](), [huet:1980:equations]() ],
convert one parse tree to an equivalent and simpler tree.
Simplifications cut out areas of the search space
and remove some paths to expressions such as $\frac{x}{1+x}$.

There is debate as to how
simplification effects the SR process 
[ [kinzett:2008:using](), [kinzett:2009:online](), [mcree:2010:symbolic]() ].
Simplifications effect the structure of the AST
through its manipulation, which in turn
effects the areas of the overall search space
reachable from a partial solutions AST.
It may be that in order to get to the best
or correct solution requires an intermediate
and illegal solution to be used.
This could also be the case if illegal operation
is replaced by a mediocre partial solution.
This can be visualized as crossing a deep ravine
in order to climb the higher mountain on the other side.
Questions remain as to 
how much and which simplifications
should be used. Further, which form of the equation 
should we keep? The original? The simplified? Both?
With a hyper-graph, we may be able to connect
all forms of an equation together,
something we will consider in the future.

The simplifications used commonly in the SR literature
are to group terms like $ax+bx$,
cancel terms like $\frac{x}{x}$, 
and to use interval arithmetic to
remove illegal operations.
In addition, depth and size bounds are often placed on the equation''s derivation tree.
Placing bounds on the tree explicitly places bounds on the search space.
Generally, a small bound on the size or depth is started with and increased
if the models returned are unsatisfactory.
















#### Evaluation in Symbolic Regression

**Point Evaluation**

**Accuracy Metrics**

**Fitness Values**


Symbolic Regression explicates relationships 
between variables using mathematical equations.
As an abstract problem, 
SR is capable of modeling many kinds of data sets.
The type of data, and 
its presentation to a SR implementation, 
determine the resultant equations producible.
The fitness function for equation evaluation
is partially the presentation. 
The available fitness functions
depend upon the independent measurements of the data.
If time is one of these, then we can consider differential equations.
To fully evaluate candidate equation
a fitness score is also calculated.
Any number of error equations can be used,
and are also dependent upon the data,
its scale, and its features.

With the variety in data and
methods of evaluation,
its no surprise SR can tackle many problems.
Results from explicit mappings,
to systems of differential equations
and even conserved quantities
have been reported in the literature
\cite{hod:09:implicit_long,hod:09:science}.
GP has also been applied to circuit design,
gene regulatory networks, and to
evolve path following algorithms.

Despite the apparent successes in GP, 
there has been a lack of sound science
in the field of SR \cite{McDermott:2012:benchmarks}
(\textit{this margin is too narrow to contain} the full list of citations).
Fair comparison requires
careful consideration of
how an implementation is measured.
SR implementations are complex
and contain subtle differences which 
can bias results if used in isolation.
The best practice is to use
multiple metrics that
demonstrate and reinforce conclusions.
Ultimately, the best measure of any SR implementation 
will be its inclusion into the research process of a domain expert.


Candidate fitness metrics,
methods for comparing implementations,
and benchmark problems
vary widely across the GP field.
\cite{McDermott:2012:benchmarks} 
surveyed three years of literature from EuroGP and GECCO GP track,
bringing this issue to the forefront of the community.
Their aim was to start a discussion
on unifying and standardizing the evaluation process
in GP.
We agree with these ideals and
use 22 of their SR target functions
for the evaluation of PGE.
Further, we believe PGE can contribute to this effort,
as a deterministic, base-line algorithm,
against which evolutionary methods can measure themselves.

We do, however, disagree with the assumption in ~\cite{McDermott:2012:benchmarks},
that results should not be expected to be repeatable,
and thus unverifiable by a third party.
A non-GP practitioner will not likely
use a tool which gives different
answers each time it is used.
This has been partially addressed by 
*rate of convergence*
(how often an implementation finds an answer)
and 
*cumulative probability of success*
(the probability that an ideal solution would be found on or prior to generation $i$).
Both of these methods require many trials.
Nevertheless, we agree that the optimum is less obtainable
and that a consensus needs to be reached 
on unbiased methods for comparison between different implementations. 


Equation evaluation involves
calculating individual fitness and 
relative comparison to other functions.
However, the type of data and its
presentation determine how we
measure error and the kind of resultant
equations we should expect.

Once we can evaluate and compare equations,
we can consider what types of problems 
an implementation can attempt.
These can be
uniformly sampled inputs as well as
time-series, data sampled over time,
and even space.

We will also want several ways
to compare implementations 
within a framework and across,
such as comparing GP and PGE. 
Each metric measures several
aspects of an implementation,
and a true evaluation can
only come by using multiple metrics
in conjunction.

**Data Presentation**

Data sets come in many varieties.
How we measure data effects
the methods we can employ
to uncover equations from that data.
One method is to uniformly sample
the input variables. This is easy
when the variables have 
a well defined range and can easily be simulated or observed.
This is the case for equations like $$y=f(\vec{x})$$.
In the real world, we have limited
access to the multitude of
states a system can exhibit.
Often the only independent variable
we can measure is time.
The dependent variables are measured
over time and produce a 
data set called a time-series.
Time-series can be presented
in ways that will 
allow SR to uncover equations
that relate the current state of the system
to the rate of change in a variable.

Running multiple experiments 
provides an increased view
of the variation within a system,
and is the norm in science.
Usually multiple initial conditions
for an experiment can be used
to give coverage to the dynamics
of a system, even capturing bifurcations.
The data can be further enriched by
include time independent variable measurements.
Examples of these are the length and mass
of a pendulum or the water temperature of a titration.
We refer to these as system parameters, 
parameters which can change value between experiment
but don't vary over the course of a single experiment.
Using multiple experimental settings with multiple initial conditions
provides a greater sampling coverage of the system dynamics.
Performing multiple experiments is good science,
but can drastically increase the
complexity and amount of data on hand.

Methods to reduce the amount
of data presented include sub-sampling
and feature selection.
Sub-sampling creates small subsets
of the original data for presentation.
These subsets give a prediction
of an equations fitness on the entire data set.
They can be modified over the course
of the search process to accentuate 
different aspects of the data set.
In \cite{hod:08:coevo_fp}, subset optimization
is merged with the equation search 
to create a co-evolutionary algorithm.
This will be discussed further in section \ref{sec-gp-adv}.
\cite{tommaso:1997:discussion} 
discusses another method of sub-sampling,
decomposing an overall problem
into subsets that emphasize different sub-tasks or partial solutions.
A learning algorithm can use the partial solutions
to the simpler tasks to construct
an overall solution to the bigger problem.



**Fitness Function**

To test hypotheses, SR requires 
a fitness score to be assigned to each candidate.
The accuracy of an individual can be measured in terms
of the difference between the output produced and the output expected.
Size is usually measured as the number of nodes,
both terminal and non-terminal,
that are contained in the tree.
Each tree is assigned a scalar value
by using a well defined procedure.
SR seeks to maximize an equations fitness
by improving accuracy while minimizing complexity.

Each equation is typically tested 
with a number of fitness cases
representing different environments or situations \cite{deb:1999:mogas}.
Its accuracy is computed by 
calculating the summed error 
for an equation on the test data, usually via
average absolute error, mean squared error, mean log error.
Less direct fitness calculations include:
total hits, which tallies the number of data points that
an equation is 'close' to, determined by a threshold.
Ranking calculates a score
based on relative order by considering 
the Pareto dominates, is dominated ratio.
The most common fitness metrics are 
mean squared error and average absolute error.

PGE uses a two step process for evaluating equations.
First, PGE uses nonlinear regression to fit
the abstract parameters, of an equation form, to a training set.
Second, the optimized form is evaluated
on testing data using one of the aforementioned fitness measures.
To perform nonlinear regression,
we make use of the Levmar C library \cite{lourakis04LM}.
Levmar provides an ANSI C implementations of the 
Levenberg-Marquardt optimization algorithm, 
both unconstrained and constrained versions
(under linear equations, inequality and box constraints). 
The Levenberg-Marquardt (LM) algorithm is an iterative technique that finds a local minimum of a function that is expressed as the sum of squares of nonlinear functions. It has become a standard technique for nonlinear least-squares problems and can be thought of as a combination of steepest descent and the Gauss-Newton method. When the current solution is far from the correct one, the algorithm behaves like a steepest descent method: slow, but guaranteed to converge. When the current solution is close to the correct solution, it becomes a Gauss-Newton method \cite{lourakis04LM}.













#### Optimization in Symbolic Regression


**Exploration Operators**


**Selection Mechanisms**


**The Pareto Front**


In multi-objective optimizations,
no one fitness measure trumps the others.
There is an irregular
trade-off between the various measures.
Many times, this trade-off is between 
real-valued error metrics when 
attempting to optimize several constraints.
In Symbolic Regression,
there are two fitness measures 
a real-valued error and a discrete size.
We prefer SR to find the simpler equations
which model the data accurately. 

The Pareto non-dominated sort,
usually just called the Pareto front,
addresses this trade-off between opposing objectives 
\cite{luke:2002:lexicographic, smits:2005:pareto, van:1998:evolutionary, fonseca:1993:genetic, horn:1994:niched}.
The Pareto front is a non-dominated sorting.
That is, no other solution is better than the solutions of the
Pareto front in both complexity and performance.
In mathematical terms, vector $\vec{u} \prec \vec{v}$ if
$\forall i, f_i(u_i) \leq f_i(v_i)$.
% \tony{ correct math definition?}
In the case of SR, we have first consider the
discrete objective, parsimony,
and then the continuous objective, accuracy.
A smaller function will always dominate
any function which is larger and less accurate.
A large function $g$ dominates $f$ when
its error is smaller.
That is to say that we accept larger
functions when they are more accurate.

The Pareto front is layered into 
non-dominating sets of equations, called frontiers.
Each frontier represents a set of equations
which maintain the non-dominance relationship.
We can remove the first frontier
to obtain the second frontier.
Appending the succesive fronts end-to-end
is often done 
to create a linear ordering 
of the equations being sorted.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.50, clip=true, trim=0 0 0 0]{imgs/pareto_front.png}
\caption[Pareto Fronts]{A series of successive Pareto Fronts}
\label{fig:pareto-front}
\end{figure}


-----

Symbolic Regression, though often called so, 
is not an algorithm itself, but rather a problem 
which is solved by an implementation.
This section introduces implementations for SR.
All three follow the same general logic:
determine each candidates fitness,
choose the best candidates, and
make new candidates from the current best candidates.

The most common method for implementing SR is GP,
a non-deterministic search heuristic.
GP has enjoyed 28 years as a field of research,
with many incremental improvements and enhancements.
FFX as a recently proposed, deterministic
algorithm for SR.
FFX moves SR towards being considered a technology.
This work introduces PGE,
a SR implementation based on dynamic programming.
PGE is deterministic, effective, efficient,
and we hope another step in
the direction of SR becoming more than research.




 

#### Memoization

Make the case

Explain GP hasn't

Prelude why it's important and even neccessary 













































<div>
<img src='/sr/img/sr-basic.png' class='responsive-img'></img>
</div>



<div id="implementations"></div>
<a class="right" href="#top">top</a>

### Implementations

Similarly, as in any machine learning task,
there are several algorithms which
try to solve the SR problem.
Originally, SR was born from Genetic Programming (GP),
an evolutionary algorithm for attempting this problem.
The use of GP as a method for SR
has been the de-facto until only recently.
It is for this reason that SR as a problem
is just starting to find itself researched
outside of evolutionary algorithms.
With the advent of Fast Function eXtraction (FFX)
and Prioritized Grammar Enumeration (PGE),
there are now competing methods to GP
which are also deterministic.

SR implementations are the
assemblages of algorithms and data structures
for representing, generating, and testing hypotheses.
The most common implementation of SR 
has been the evolutionarily inspired method
called Genetic Programming (GP).
More recently, Fast Function eXtraction (FFX)
was proposed as the first deterministic SR implementation,
based on ridge and lasso regressions.
The main contribution of this work is
Prioritized Grammar Enumeration (PGE),
a second deterministic implementation,
with foundations in dynamic programming.
We will briefly describe each here
with further details in subsequent chapters.


#### Genetic Programming

*re-edit after related work chapter done*

GP is a stochastic search heuristic
for searching a space of expressions.
GP uses natural selection
to evolve models representable by 
a parse tree within a grammar. 
GP requires six components to be defined:
representation, evaluation, selection, genetic operators, 
initialization and termination, and population management.

GP uses the aforementioned components to refine
equations in an iterative, or generational, process.
GP starts by creating a 
random population of initial equations.
During each generation, 
individuals in this population are 
evaluated for fitness,
selected for survival and replication,
and then recombined using
sexual reproduction and mutation.
GP continues in this fashion until
a model of desired accuracy is discovered,
or a computational threshold is reached.
This process uses information learned
through evolutionary progress
to guide the future search direction. 

GP, as a non-deteriministic algorithm
comes with a host of issues.
These issues stem from problems created
by the representation, the effect of the
genetic operators, and the difficulties
in maintaining a diverse population of equations.
These limitations, however, offer opportunity
for advancement, and GP has seen dozens of papers
each year. Chapter 3 will give
a more detailed account of these limitations
and the advancements in the fields of GP and SR.







#### Fast Function eXtraction

*re-edit after RelatedWork chapter done*

Fast Function eXtraction (FFX)
is a deterministic SR implementation \cite{McConaghy:2011:FFX}.
FFX does not use genetic operators or
a tree based representation.
Instead, FFX uses a Generalized Linear Model (GLM).
GLM is a linear combination of expressions in the form: 
\begin{equation} 
\label{eqn:linear}
    y = F(\vec{x},\vec{w}) = \sum \limits_b^B w_b f_b(\vec{x}) 
\end{equation}
The $f(\vec{x})$ are not required to be linear functions themselves,
but rather linear in coefficients, to the terms of the summation.
In other words, there are no
coefficients inside any of the $f_b(\vec{x})$. \\

FFX first creates a set of 
univariate bases from each variable
with the operations ($x^{\pm 0.5}, x^{\pm 1}, x^{\pm2}, abs(x),log(x)$).
In their example this produced 176 bases.
Next, the univariate bases were combined
to produce 3374 bivariate bases,
resulting in 3550 total bases.
By allowing bases to be in both the
numerator and the denominator,
the overall number of bases doubles to 7100.
% \tony{these numbers seem to be off: 13var * 3pow * 5ops = 195}

For all $b$ from $b \rightarrow B$,
FFX derives a linear combination of
$b$ basis functions.
To learn a model, FFX applies
pathwise regularized learning
to fit the GLM coefficients.
This learning method uses
a coefficient threshold value $\lambda$ and varied it until
the number of function bases equals the desired model complexity.
FFX returns all of the models sorted,
using the non-dominated Pareto sort.

FFX works well for many problems,
requiring far fewer computations GP,
but is limited in the complexity of solutions.
This limitation of FFX is due to only using
a linear combination of univariate and bivariate bases.
Equations such as $v = x*y*z$ are beyond the
abilities of FFX.
Additionally, there are no coefficients 
or parameters within the bases.
FFX can use non-linear functions,
like $\cos$ and $log$,
but non-linear fitting is not possible.
Thus, equations such as $e^{a-bx}$ and $a\cos(b+\theta)$
are also unsolvable by FFX.
As FFX is incapable of finding
many of the benchmarks,
we did not implement the algorithm
or compare against it.




\begin{figure}[h!]
\lstset{caption={PGA Search Function},label=pga_srch_func}
\begin{lstlisting}
func PGE_Search() {
  eqns := createBasisFunctions()
  IPT.insert(eqns)
  eqns.FitCoefficents(TrainData)
  eqns.Evaluate(TestData)
  PPQ.push(eqns)

  while !done {
    top := PPQ.pop(p_eqns)
    new_eqns := Expand(top)
    
    for e := range new_eqns {
      did_ins := IPT.insert(e)
      if did_ins {
        e.FitCoefficents(TrainData)
        e.Evaluate(TestData)
        PPQ.push(e)
      }
    }
  }
}
\end{lstlisting}
\end{figure}


#### Prioritized Grammar Enumeration

*re-edit after PGE chapter done*

This work introduces Prioritized Grammar Enumeration (PGE), 
the first tree based implementation of Symbolic Regression.
PGE solves the symbolic regression problem by 
working \textit{with} a grammar, 
to prioritize the enumeration of expressions in that grammar.
PGE uses the grammar's production rules 
to turn simple basis functions 
into increasingly complex expressions. 
PGE is a dynamic programming algorithm and is also deterministic.
PGE considers a model \textit{form} only once,
by employing memoization,
a priority queue, and non-linear regression. 
PGE combines the flexibility of GP 
with the reliability of FFX. 

Initially, PGE starts with 
a set of basis functions:
$c_0*x_i$, $\frac{c_0}{x_i}$, and $N(x_i)$.
Each basis function is 
fit to the training data,
evaluated on the testing data,
and placed into the Pareto Priority Queue (PPQ).
The PGE algorithm iteratively
pops equations from the top of the queue for processing.
Each of these equations is expanded
by applying the grammar's production rules recursively.
The new equations are memoized using
a specialized structure, the Integer Prefix Tree (IPT).
The IPT uses an equation's serialized representation
to track which solutions have been processed already.
The IPT ensures that we only consider 
an equation form once.
This allows PGE to eliminate duplication of effort
in evaluation and expansion.
Unique equations are
fit to the training data, 
evaluated on the test data, 
and pushed into the priority queue.
PGE continues until
a model of desired accuracy is discovered
or a computational threshold is reached.

Variations on the PGE algorithm
can be created by altering how initialize PGE
and step through the grammar via its production rules.
We can seed PGE with a richer set of basis function,
and even allow complete sub-trees to become building blocks.
Further, by enriching the production rules applied at each node,
we can enlarge the set of equations generated at each point in the search space.
One variation of PGE is even 
similar to reversing the FFX pruning into growing (Section \ref{subsec-pge-vari-genfuncs}).
These variation will be discussed in detail
in Section \ref{sec-pge-vari}.














<br>

<div id="applications">
<a class="right" href="#top">top</a>
</div>

### Applications

Symbolic Regression can, and has been,
applied to many problems from a multitude of domains.
This is possible because the underlying 
tree or trie can represent multiple types of equations.
The different types of equation can, in turn,
model different problems. Here we describe
the different types of equations
and provide some sample applications.

#### Equation Types


| Problem Type            | Target Equation Form |
| ----------------------- | -------------------- |
| Explicit Equations      |  $$ y = f(\vec{x}) $$ |
| Differential Equations  |  $$ \frac{dx_i}{dt} = f(\vec{x}) $$ |
| Invariants              |  $$ F(\vec{x}) = C $$ |


**Explicit Equations**

Explicit functions are the most basic equation type.
These are a direct mapping, or rule,
from the independent input variables to the dependent output variable.
Data is plugged in and the output is the result of depth-first evaluation. 
The most familiar of these is the line: $$ y = ax + b $$.
The line has one input variable and 
one output variable.
Other familiar examples are the polynomial: $$ y = ax^2 + bx + c $$
and the plane: $$ z = ax + by + c $$.
A real-world example is calculating housing price
based on square footage and other features of a house.


**Differential Equations and Dynamical Systems**

Differential equations are functions which
relate a quantity to its rate of change.
They are prominent through the sciences.
Dynamical systems are a set of differential equations,
either heterogeneous or homogeneous.
Each differential equations, in turn,
is a rule for the rate of change,
in one variable over time, to the current state of all variables.
That is to say that the future depends upon the past.

To evaluate differential equations,
techniques of numerical integration are required.
There are many methods of numerical integration [[kress:98:num_analysis]()].
Runge-Kutta 4 (RK4) is one such technique.
It makes four smaller steps in time, 
updating the input variables along the way.
Since RK4 involves four evaluations of a function,
it requires four times the computational effort.
RK4 also requires all of the differential equations, 
for a dynamical system, in order to simulate the system.
RK4 integrates from current state to produce the
next state of the system. It thus requires
a temporal ordering of the data.
We use the RK4 algorithm in this work
to produce the data sets for the dynamical systems.

When performing an SR search, it is possible
to decompose the differential equations for separate evaluation.
We can approximate the integrated values
of the other variables
by substituting interpolated data.
This partitions the SR search 
making the equation recovery simpler task [ [hod:07:pnas]() ].
We call this Partitioned RK4 (PRK4).
PRK4 requires the current and next
states of the system, and four evaluations,
in order to measure the fitness of an equation.
It also maintains the temporal restriction
of data in the evaluation process.

An alternative evaluation method
for differential equations
exists, if the numerical derivatives 
of the data can be calculated.
The equations fitness is then
measured by its ability to predict 
the numerical derivative.
There are two reasons for doing this.
The first is that small variations in the equation
result in a larger magnitude 
of difference from the fitness function.
The integrals of $$x^2$$ and $$x^2+1$$ 
diverge linearly, which means the
integrated values of RK4 are very similar.
The fitness landscape of the
numerical derivative method is less smooth.
The second reason for evaluating
against the numerical derivative data
is that we can perform a single point evaluation.
We perform four times fewer evaluations
and we can perform them at arbitrary points
[ [hod:08:mining]() ].



**Invariants and Partial Differential Equations**

The natural extension to differential equations
is Partial Differential Equations (PDE).
They are analogous in that they relate a function
to rate of change.
PDEs allow more than one independent variable,
such as x, y, and z in three dimensional space.
Invariant represent the solution to 
such a system system and are also called a conserved quantity.
Well known examples from physics are 
the conservation of energy, mass, and angular momentum.
Previous work has shown that it is actually possible to
uncover the Hamiltonians for conservation of angular momentum,
directly from measured data [ [hod:09:science](), [hod:09:implicit_long]() ]. 
This begs the question:

<blockquote>
Are there conserved quantities in biological or ecological systems.
</blockquote>

Despite the potential for, PDEs and invariants are beyond the scope of this work.






















<br>

 
<div id="considerations"></div>
<a class="right" href="#top">top</a>

### Further Considerations



#### Separating Task from Implementation


In this work, we view SR as only a problem
and view GP as an algorithm for performing SR.
We attempt to make a distinction which
the SR literature has not by using GP
as a term for both the problem *and* solution.
We view SR, not as a sub-class, 
but as a super-class to GP, 
as the regression within a grammar. 
A particular programming language is a specific grammar
and an instance of the SR problem.
So can be circuit or atomic regression.
Mathematical equations are another instance of the SR problem
and the one we focus on.

We want to reiterate the difference
between problem and implementation.
Symbolic Regression is the task
which uncovers relationships in data
by searching the expression space defined by grammar.
An implementation is the assemblage of methods
which realize the Symbolic Regression task. 
We believe the lack of separation has 
led to some missed opportunities is SR research.
In this work, we step back from SR
to fundamentally change the way we
think about regressing symbolic expressions.

We also make this distinction 
because recent work [[McConaghy:2011:FFX]()]
introduces, to our knowledge, the first
deterministic algorithm for SR called
Fast Function eXtraction (FFX),
offering a new means of performing an equation search.






#### Benchmark Problems


#### Metrics for Success

**Accuracy of Candidate Solutions**

Accuracy predicts a candidates
ability to model a given data set.
Depending on the goals in using SR
accuracy may or may not be the right measure.
If we seek the most predictive model
then accuracy can tell us which model is best.
However, it is often the goal in SR
to provide insight through meaningful relations.
This is the trade-off between
accuracy and parsimony.
We want the simplest equation
that isn't to simple.
In SR, we usually return multiple models
instead of one single best model.
This allows the domain expert can
evaluate the varying 
degrees of complexity and accuracy.

It is usually the case 
that the most accurate model
has also over fit the data set.
Over fit models high frequency signals within the data
by adding subexpressions to fit these signals.
Validation sets overcome this issue by 
testing the model on unseen data 
after training. 
This results is an unbiased measurement,
unless the learner is also being optimized.
In that case, cross validation or
a third data set is used as
the never-before-seen testing data.


**Rate of Convergence**

The rate of convergence is defined as 
an implementation's probability
of finding the correct solution.
This metric is because
GP is a randomized algorithm
which produces inconsistent results.% \cite{}.
A randomized algorithm's results
depend on the initial starting points.
GP has non-deterministic behavior when
creating the initial equation population
and when genetic operations are applied during breeding.
To compensate for the lack of consistency,
GP researchers run many trials. 
The final results of all runs are tallied
to come up with a probability for success.
Rate of convergence can be a good measure
when comparing the relative efficacy of GP implementations.
It can also be used to tune the
parameters of the GP implementation.

PGE doesn't have a rate of convergence.
It is a deterministic algorithm
which executes the same way,
in the same order,
every time.
Thus, given a set of parameters,
PGE will either find the solution or it will not.
The ability of PGE to find a solution depends
upon the expansion functions and the 
amount of time alloted for searching.

Rate of convergence will not allow
us to make direct comparison between GP and PGE.
It will permit us to loosely infer problem complexity 
with the both implementations
difficulty in finding the 'correct' solution.
Further complicating this issue is that
determining convergence is not well defined.
The literature has used 
hit ratio,
error thresholds,
and $R^2$ correlation.
Real convergence is the matching of form,
which can be done by manual inspection
or by tree comparisons.
To our knowledge, no one has
reported this type of convergence
by directly stating how close 
the results are to the true form.

% for convergence rate:
% who hod compares against
%   - success == hits
%   - hit == <0.01 error on a point
% hod defines as 
%   - in implicit: error < e, but doesn't give e
%   - graph: .9999 correlation







#### Metrics for Effort

**Number of Iterations**
is often equated with how many steps
it takes to find a solution.
GP has a natural step between parents and children
and is referred to as generations.
Each generational step 
uses the current solutions and genetic operators
to produce new candidate solutions.
The number of generations is
loosely tied to how long it
takes a GP implementation to 
converge to an answer.
In PGE, the generational step
is applying the grammar productions
to the best candidate solutions.

Measuring performance by iterations
is easily a biased measure.
It requires careful attention to detail. 
Different implementations use
different logic and parameters, 
searching different amounts of equation space per iteration.
Varying the number of equations
or the layout of the population
effects the search rate.
Fewer iterations is not always better,
but can be a useful measure to minimize
when optimizing the parameters
within a particular SR implementation.
When comparing between implementations,
iterations becomes misleading if
other factors are not considered.


**Clock Time**

Clock time tells us how long, 
from when we hit enter,
until we get our answer.
All other considerations equal,
it is an unbiased measure.
Generally every thing is not equal,
and why comparing several measures is useful
and no measure should be used in isolation.

At some point, algorithms and computers
become fast enough at a problem
that time becomes less of an issue.
To a domain expert, 
the difference between an hour and two,
or hours and a day, may not be important.
When they are modeling a large data set
for a particular problem,
a 24 hour turnaround is often acceptable,
especially when one considers the time 
it takes to publish in a journal.

Time, despite being something not to fool with,
is a powerful measure. Small incremental improvements
compound in time to create meaningful progress.
When time is coupled with other metrics,
we can gain measures for the amount of work.


**Amount of Work**

Amount of work done is a good metric when
we want the most return for what we put in.
Work, however, can be difficult no quantify.
In SR, work is usually measured by counting
the number of evaluations made,
and relating this measurement over time.

Counting evaluations is easy in GP.
Calculation is population size
multiplied by generations and the number of data points.
A refinement to counting evaluations
is to recording the ratio of unique equations 
to total number equations evaluated.
To our knowledge, 
no one has reported 
using this measure. 
Our memoization structure, the IPT, 
will allow us to relay interesting results
on the number of unique equations
compared to the total number of equations
by both GP and PGE.


% Counting the number of candidates tells us 
% how many equations we actually considered.
% If we count the number of evaluations we
% made on each equation, we get a measure of work. 
% \[
% Work=|Cand|x|Eval|
% \]
% Most work occurs during
% the evaluation phase of the search process. 
% The computation complexity of simulation and evaluation,
% far outweighs the time taken for 
% the remainder of the search process.
% We can reduce this work by 
% reducing either of the terms, 
% number of equations or number of evaluations.


% We can further refine this by considering 
% the number of unique equations evaluated
% compared to the total number.
% We want to be smart about
% how many and which,
% equations and data points we choose.
% Coupling the unique to total equations
% with the number of evaluations
% will provide us a good comparison
% between the SR implementations.
% GP evaluates many equations
% fewer times, but experiences
% great amount of redundancy in form.
% PGE spends a larger amount of
% effort per equation,
% considers a form only once.













In order to compare SR implementations,
and before trusting them on unsolved problems,
methods for quantifying the effectiveness
of their search capabilities are needed.

Before describing each measure 
we would like to note that
the performance quantification methods represent 
differing objectives and measurements of performance
and should not be used in isolation.
There is inconsistent use,
and wide range, of measures
in the SR literature
which can make comparison difficult at times.







Consider clock time, which can give us insight into
how time to solution scales with solution complexity,
gives no insight into the quality of the solution.
Couple this with accuracy and gain a measure of quality,
but we are still left without knowledge of the
implementations ability to create meaningful models.
As one could imagine,
using a single or limited set of measures can result in 
misleading or biased comparisons.


The methods employed include:
accuracy, number of evaluations performed, number of candidates tested
number of generations or iterations, rate of convergence, and clock time.
Some measures are biased towards
one or another SR implementation,
depending on the setup and framework.
Clock time is a relatively unbiased measure
if the environment is the same and is closely
related to the amount of work performed by a SR implementation.
Further, when using certain measures,
other measures become the terminating condition
upon which we base the original measure.
Alternating variations include,
counting the number of iterations until the best solution's accuracy meets a threshold,
or running for a predefined number of iterations and reporting the level of accuracy achieved.
In this way, the efficacy measure, as well as
the termination condition we choose,
create an interplay of measures and parameters
which must also be taken into consideration
when drawing conclusions about an implementation.
















#### Reproducibility and the Importance of Determinism


This deterministic nature of FFX and PGE
is an important feature for a SR algorithm.
It is because of the link between
human, math, and science.
In science we expect reproducible results.
We believe this is why GP has not
become a predominant technology as predicted by its proponents,
and likewise, SR for being so tightly coupled to GP
for much of its history.
Here, we take a strong stance that reproducibility
is one of the key features to a SR implementation.
Reproducibility provides the necessary reliability
for scientific discovery and adoption of a new tool, 
as well as the foundation upon which research into SR
can stand.



issues of reproducibility in SR and GP

\subsection{The Importance}
\subsection{Systems for Reproducibility}




 Candidate fitness metrics,
methods for comparing implementations,
and benchmark problems
vary widely across the GP field.
Last year, [McDermott:2012:benchmarks]() 
surveyed three years of literature from EuroGP and GECCO GP track,
bringing this issue to the forefront of the community.
Their aim was to start a discussion
on unifying and standardizing the evaluation process
in GP.
We agree with these ideals and
use 22 of their SR target functions
for the evaluation of PGE.
Further, we believe PGE can contribute to this effort,
as a deterministic, base-line algorithm,
against which evolutionary methods can measure themselves.
% \tony{(last paragraph of Section 5) [copied into tex file]}
We do, however, disagree with the assumption in ~\cite{McDermott:2012:benchmarks},
that results should not be expected to be repeatable,
and thus unverifiable by a third party.
A non-GP practitioner will not likely
use a tool which gives different
answers each time it is used.
This has been partially addressed by 
\textit{rate of convergence}
(how often an implementation finds an answer)
and 
\textit{cumulative probability of success}
(the probability that an ideal solution would be found on or prior to generation $i$).
Both of these methods require many trials.
Nevertheless, we agree that the optimum is less obtainable
and that a consensus needs to be reached 
on unbiased methods for comparison between different implementations. 

% \tony{
% want to add a paragraph about metrics for implementations and benchmarks.
% covering the many methods, but definitely
% rate of convergence in its two forms 
% (1) how often a solution is found
% (2) how long before the algorithm reaches a local optima and stops making progress
% Then bring in paper about "GP needs better benchmarks"
% and comment on their comment about 
% finding exact solutions isn't important as accuracy
% b/c in industry solutions are not known
% (my comment is that industry won't trust an implementation
% that can't return the correct answer to known problems)
% they do comment on the lack of rigor in benchmarking GP
% and have sought to bring unity to this (which I like)
% }


% 5. APPROPRIATE STATISTICS
% Suggesting or adopting standard benchmarks in itself is
% not enough to produce meaningful results: the statistical
% procedure for comparing methods is crucial, and effective
% comparison benefits from consistency in the literature in this
% regard. How should we perform such comparisons?
%
% A large portion of early (and indeed current) GP results
% were measured using ideal solution counts: whether or how
% often the optimum, or some threshold near the optimum,
% was reached. The most common approach [32] defined the
% computational effort measure as an estimate of the minimum
% number of individuals to be processed in a generational
% algorithm in order to achieve a z = 99% probability of
% discovering a solution. More formally, this was defined as
%
% min_i m  (i + 1)   { ln(1z) / ln(1P(m,i)) }
%
% , where i was a generation
% number, m was the population size, and P (m, i) was the
% cumulative probability of success, that is, the probability that
% an ideal solution would be found on or prior to generation i,
% as gathered through samples.
%
% This measure has received significant criticism [51, 7, 43, 47,
% 4]. Critics have noted that ideal solution counts are really a
% measure of how well a method solves trivial problems, rather
% than the nontrivial ones found in real world applications.
% Attempts have since been made to address another central
% criticism: poor accuracy and statistical invalidity [8, 68].
%
% We think that benchmark comparison measures should
% instead assume that techniques will be applied, ultimately,
% to problems where the optimum is not expected to be discov-
% ered, much less repeatedly and easily. For single objective
% problems, two obvious candidates are best fitness of run (ap-
% propriate for problems where the goal is optimization) and
% generalizability measures such as final testing against a with-
% held generalization set, or K-fold validation (appropriate for
% problems where the goal is to perform model-fitting).

% \com{Interesting discussion paragraph to add.
% Very comprehensive background of GP for a conference paper.  If you need room, you could probably cut some of the details here.
% Question about flow:
% As it appears to me now, I see:
% Intro GP, lots of ways it gets done,  then a bit on other SR methods, then back to applications of GP, then metrics and benchmarks.
% Consider reorganizing: equal amounts on GP (can focus on more recent advances) and SR (maybe less on SR since you touch  on it in the intro).  Keep the two topics as separate as possible to make the discussion easier to follow.

% You do a good job highlighting the limitations of each approach, and that's a good thing to keep, especially if PGE does not have those limitations.}






